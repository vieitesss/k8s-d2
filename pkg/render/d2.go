package render

import (
	"fmt"
	"io"
	"strings"

	"github.com/vieitesss/k8s-d2/pkg/model"
)

type D2Renderer struct {
	w           io.Writer
	gridColumns int
}

func NewD2Renderer(w io.Writer, gridColumns int) *D2Renderer {
	return &D2Renderer{
		w:           w,
		gridColumns: gridColumns,
	}
}

func (r *D2Renderer) Render(cluster *model.Cluster) error {
	if cluster == nil {
		return fmt.Errorf("cluster is nil, cannot render")
	}

	header := `# Generated by k8s-d2
direction: right

`
	if _, err := fmt.Fprint(r.w, header); err != nil {
		return err
	}

	if err := r.renderLegend(); err != nil {
		return err
	}

	if r.gridColumns > 0 {
		if _, err := fmt.Fprintf(r.w, "namespaces: {\n  grid-columns: %d\n\n", r.gridColumns); err != nil {
			return err
		}
		for _, ns := range cluster.Namespaces {
			if err := r.renderNamespaceIndented(&ns, "  "); err != nil {
				return err
			}
		}
		if _, err := fmt.Fprint(r.w, "}\n"); err != nil {
			return err
		}
	} else {
		for _, ns := range cluster.Namespaces {
			if err := r.renderNamespaceIndented(&ns, ""); err != nil {
				return err
			}
		}
	}

	return nil
}

func (r *D2Renderer) renderNamespaceIndented(ns *model.Namespace, indent string) error {
	nsID := SanitizeID(ns.Name)
	var b strings.Builder

	fmt.Fprintf(&b, "%s%s: {\n", indent, nsID)
	fmt.Fprintf(&b, "%s  label: %s\n", indent, ns.Name)
	fmt.Fprintf(&b, "%s  grid-columns: 3\n", indent)
	fmt.Fprintf(&b, "%s  style.fill: \"#f0f0f0\"\n\n", indent)

	r.writeAllWorkloads(&b, ns, indent)
	r.writeAllServices(&b, ns, indent)
	r.writeConfigInfo(&b, ns, indent)
	r.writePVCs(&b, ns, indent)
	r.writeConnections(&b, ns, indent)

	b.WriteString(fmt.Sprintf("%s}\n\n", indent))
	if _, err := fmt.Fprint(r.w, b.String()); err != nil {
		return err
	}
	return nil
}

func (r *D2Renderer) writeAllWorkloads(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, w := range ns.Deployments {
		r.writeWorkload(b, &w, indent)
	}
	for _, w := range ns.StatefulSets {
		r.writeWorkload(b, &w, indent)
	}
	for _, w := range ns.DaemonSets {
		r.writeWorkload(b, &w, indent)
	}
}

func (r *D2Renderer) writeAllServices(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, svc := range ns.Services {
		r.writeService(b, &svc, indent)
	}
}

func (r *D2Renderer) writeConfigInfo(b *strings.Builder, ns *model.Namespace, indent string) {
	if ns.ConfigMaps > 0 || ns.Secrets > 0 {
		fmt.Fprintf(b, "%s  _config: {\n", indent)
		fmt.Fprintf(b, "%s    label: \"CM: %d | Sec: %d\"\n", indent, ns.ConfigMaps, ns.Secrets)
		fmt.Fprintf(b, "%s    style.fill: \"#ffffcc\"\n", indent)
		fmt.Fprintf(b, "%s  }\n", indent)
	}
}

func (r *D2Renderer) writePVCs(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, pvc := range ns.PVCs {
		pvcID := SanitizeID(pvc.Name)
		label := fmt.Sprintf("üíæ %s", pvc.Name)
		if pvc.Capacity != "" {
			label = fmt.Sprintf("%s\\n%s", label, pvc.Capacity)
		}
		if pvc.StorageClass != "" {
			label = fmt.Sprintf("%s\\n[%s]", label, pvc.StorageClass)
		}
		fmt.Fprintf(b, "%s  pvc_%s: {\n", indent, pvcID)
		fmt.Fprintf(b, "%s    label: \"%s\"\n", indent, label)
		fmt.Fprintf(b, "%s    style.fill: \"#e6f3ff\"\n", indent)
		fmt.Fprintf(b, "%s  }\n", indent)
	}
}

func (r *D2Renderer) writeWorkload(b *strings.Builder, w *model.Workload, indent string) {
	wID := SanitizeID(w.Name)
	icon := WorkloadIcon(w.Kind)

	fmt.Fprintf(b, "%s  %s: {\n", indent, wID)
	fmt.Fprintf(b, "%s    label: \"%s %s (%d)\"\n", indent, icon, w.Name, w.Replicas)
	fmt.Fprintf(b, "%s  }\n", indent)
}

func (r *D2Renderer) writeService(b *strings.Builder, svc *model.Service, indent string) {
	svcID := SanitizeID(svc.Name)

	fmt.Fprintf(b, "%s  svc_%s: {\n", indent, svcID)
	fmt.Fprintf(b, "%s    label: \"‚éà %s\\n%s\"\n", indent, svc.Name, svc.Type)
	fmt.Fprintf(b, "%s    style.fill: \"#cce5ff\"\n", indent)
	fmt.Fprintf(b, "%s  }\n", indent)
}

func (r *D2Renderer) writeConnections(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, svc := range ns.Services {
		if len(svc.Selector) == 0 {
			continue
		}
		r.writeServiceConnections(b, &svc, ns, indent)
	}

	// Only render workload-to-PVC connections if PVCs are actually present
	if len(ns.PVCs) > 0 {
		r.writeWorkloadPVCConnections(b, ns, indent)
	}
}

// formatMountLabel creates a compact label for volume mounts.
// Single mount: "/var/log/app (rw)"
// Multiple mounts: "/data (rw)\\n/backup (ro)"
// Note: Uses \\n for D2 newlines in labels.
func formatMountLabel(mounts []model.VolumeMount) string {
	labels := make([]string, len(mounts))
	for i, m := range mounts {
		accessMode := "rw"
		if m.ReadOnly {
			accessMode = "ro"
		}
		labels[i] = fmt.Sprintf("%s (%s)", m.MountPath, accessMode)
	}
	return strings.Join(labels, "\\n")
}

func (r *D2Renderer) writeWorkloadPVCConnections(b *strings.Builder, ns *model.Namespace, indent string) {
	workloadGroups := [][]model.Workload{ns.Deployments, ns.StatefulSets, ns.DaemonSets}

	for _, workloads := range workloadGroups {
		for _, w := range workloads {
			if len(w.VolumeMounts) == 0 {
				continue
			}

			workloadID := SanitizeID(w.Name)

			// Group mounts by PVC (handle case where same PVC mounted at multiple paths)
			mountsByPVC := make(map[string][]model.VolumeMount)
			for _, mount := range w.VolumeMounts {
				mountsByPVC[mount.PVCName] = append(mountsByPVC[mount.PVCName], mount)
			}

			for pvcName, mounts := range mountsByPVC {
				pvcID := SanitizeID(pvcName)
				label := formatMountLabel(mounts)
				fmt.Fprintf(b, "%s  %s -> pvc_%s: \"%s\"\n", indent, workloadID, pvcID, label)
			}
		}
	}
}

func (r *D2Renderer) writeServiceConnections(b *strings.Builder, svc *model.Service, ns *model.Namespace, indent string) {
	svcID := SanitizeID(svc.Name)
	allWorkloads := [][]model.Workload{ns.Deployments, ns.StatefulSets, ns.DaemonSets}

	for _, workloads := range allWorkloads {
		for _, w := range workloads {
			if LabelsMatch(svc.Selector, w.Labels) {
				wID := SanitizeID(w.Name)
				fmt.Fprintf(b, "%s  svc_%s -> %s\n", indent, svcID, wID)
			}
		}
	}
}

func (r *D2Renderer) renderLegend() error {
	legend := `
legend: {
  label: "LEGEND"
  grid-rows: 1
  style.fill: "#fffacd"
  style.stroke: "#000000"
  style.stroke-width: 3
  style.font-size: 16
  style.bold: true

  deployment: {
    label: "‚óè Deployment"
    style.fill: "#f9f9f9"
  }

  statefulset: {
    label: "‚óâ StatefulSet"
    style.fill: "#f9f9f9"
  }

  daemonset: {
    label: "‚óà DaemonSet"
    style.fill: "#f9f9f9"
  }

  service: {
    label: "‚éà Service"
    style.fill: "#cce5ff"
  }

  config: {
    label: "ConfigMaps | Secrets"
    style.fill: "#ffffcc"
  }

  pvc: {
    label: "üíæ PVC"
    style.fill: "#e6f3ff"
  }
}
`
	if _, err := fmt.Fprint(r.w, legend); err != nil {
		return err
	}
	return nil
}

// SanitizeID converts a Kubernetes resource name to a valid D2 identifier.
// D2 syntax doesn't allow hyphens, so we convert them to underscores.
func SanitizeID(s string) string {
	return strings.ReplaceAll(s, "-", "_")
}

// WorkloadIcon returns the D2 icon for a workload type.
func WorkloadIcon(kind string) string {
	switch kind {
	case "StatefulSet":
		return "‚óâ"
	case "DaemonSet":
		return "‚óà"
	default:
		return "‚óè"
	}
}

// LabelsMatch checks if a selector matches a set of labels.
// All selector key-value pairs must match the labels for this to return true.
func LabelsMatch(selector, labels map[string]string) bool {
	if len(selector) == 0 {
		return false
	}

	for key, value := range selector {
		if labels[key] != value {
			return false
		}
	}
	return true
}
