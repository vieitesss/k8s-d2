package render

import (
	"fmt"
	"io"
	"strings"

	"github.com/vieitesss/k8s-d2/pkg/model"
)

type D2Renderer struct {
	w           io.Writer
	gridColumns int
}

func NewD2Renderer(w io.Writer, gridColumns int) *D2Renderer {
	return &D2Renderer{
		w:           w,
		gridColumns: gridColumns,
	}
}

func (r *D2Renderer) Render(cluster *model.Cluster) error {
	if cluster == nil {
		return fmt.Errorf("cluster is nil, cannot render")
	}

	header := `# Generated by k8s-d2
direction: right

`
	fmt.Fprint(r.w, header)

	r.renderLegend()

	if r.gridColumns > 0 {
		fmt.Fprintf(r.w, "namespaces: {\n  grid-columns: %d\n\n", r.gridColumns)
		for _, ns := range cluster.Namespaces {
			r.renderNamespaceIndented(&ns, "  ")
		}
		fmt.Fprint(r.w, "}\n")
	} else {
		for _, ns := range cluster.Namespaces {
			r.renderNamespaceIndented(&ns, "")
		}
	}

	return nil
}

func (r *D2Renderer) renderNamespaceIndented(ns *model.Namespace, indent string) {
	nsID := sanitizeID(ns.Name)
	var b strings.Builder

	fmt.Fprintf(&b, "%s%s: {\n", indent, nsID)
	fmt.Fprintf(&b, "%s  label: %s\n", indent, ns.Name)
	fmt.Fprintf(&b, "%s  grid-columns: 3\n", indent)
	fmt.Fprintf(&b, "%s  style.fill: \"#f0f0f0\"\n\n", indent)

	r.writeAllWorkloads(&b, ns, indent)
	r.writeAllServices(&b, ns, indent)
	r.writeConfigInfo(&b, ns, indent)
	r.writeConnections(&b, ns, indent)

	b.WriteString(fmt.Sprintf("%s}\n\n", indent))
	fmt.Fprint(r.w, b.String())
}

func (r *D2Renderer) writeAllWorkloads(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, w := range ns.Deployments {
		r.writeWorkload(b, &w, indent)
	}
	for _, w := range ns.StatefulSets {
		r.writeWorkload(b, &w, indent)
	}
	for _, w := range ns.DaemonSets {
		r.writeWorkload(b, &w, indent)
	}
}

func (r *D2Renderer) writeAllServices(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, svc := range ns.Services {
		r.writeService(b, &svc, indent)
	}
}

func (r *D2Renderer) writeConfigInfo(b *strings.Builder, ns *model.Namespace, indent string) {
	if ns.ConfigMaps > 0 || ns.Secrets > 0 {
		fmt.Fprintf(b, "%s  _config: {\n", indent)
		fmt.Fprintf(b, "%s    label: \"CM: %d | Sec: %d\"\n", indent, ns.ConfigMaps, ns.Secrets)
		fmt.Fprintf(b, "%s    style.fill: \"#ffffcc\"\n", indent)
		fmt.Fprintf(b, "%s  }\n", indent)
	}
}

func (r *D2Renderer) writeWorkload(b *strings.Builder, w *model.Workload, indent string) {
	wID := sanitizeID(w.Name)
	icon := workloadIcon(w.Kind)

	fmt.Fprintf(b, "%s  %s: {\n", indent, wID)
	fmt.Fprintf(b, "%s    label: \"%s %s (%d)\"\n", indent, icon, w.Name, w.Replicas)
	fmt.Fprintf(b, "%s  }\n", indent)
}

func (r *D2Renderer) writeService(b *strings.Builder, svc *model.Service, indent string) {
	svcID := sanitizeID(svc.Name)

	fmt.Fprintf(b, "%s  svc_%s: {\n", indent, svcID)
	fmt.Fprintf(b, "%s    label: \"⎈ %s\\n%s\"\n", indent, svc.Name, svc.Type)
	fmt.Fprintf(b, "%s    style.fill: \"#cce5ff\"\n", indent)
	fmt.Fprintf(b, "%s  }\n", indent)
}

func (r *D2Renderer) writeConnections(b *strings.Builder, ns *model.Namespace, indent string) {
	for _, svc := range ns.Services {
		if len(svc.Selector) == 0 {
			continue
		}
		r.writeServiceConnections(b, &svc, ns, indent)
	}
}

func (r *D2Renderer) writeServiceConnections(b *strings.Builder, svc *model.Service, ns *model.Namespace, indent string) {
	svcID := sanitizeID(svc.Name)
	allWorkloads := [][]model.Workload{ns.Deployments, ns.StatefulSets, ns.DaemonSets}

	for _, workloads := range allWorkloads {
		for _, w := range workloads {
			if labelsMatch(svc.Selector, w.Labels) {
				wID := sanitizeID(w.Name)
				fmt.Fprintf(b, "%s  svc_%s -> %s\n", indent, svcID, wID)
			}
		}
	}
}

func labelsMatch(selector, labels map[string]string) bool {
	if len(selector) == 0 {
		return false
	}

	for key, value := range selector {
		if labels[key] != value {
			return false
		}
	}
	return true
}

func sanitizeID(s string) string {
	return strings.ReplaceAll(s, "-", "_")
}

func workloadIcon(kind string) string {
	switch kind {
	case "StatefulSet":
		return "◉"
	case "DaemonSet":
		return "◈"
	default:
		return "●"
	}
}

func (r *D2Renderer) renderLegend() {
	legend := `
legend: {
  label: "LEGEND"
  grid-rows: 1
  style.fill: "#fffacd"
  style.stroke: "#000000"
  style.stroke-width: 3
  style.font-size: 16
  style.bold: true

  deployment: {
    label: "● Deployment"
    style.fill: "#f9f9f9"
  }

  statefulset: {
    label: "◉ StatefulSet"
    style.fill: "#f9f9f9"
  }

  daemonset: {
    label: "◈ DaemonSet"
    style.fill: "#f9f9f9"
  }

  service: {
    label: "⎈ Service"
    style.fill: "#cce5ff"
  }

  config: {
    label: "ConfigMaps | Secrets"
    style.fill: "#ffffcc"
  }
}
`
	fmt.Fprint(r.w, legend)
}
